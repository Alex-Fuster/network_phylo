---
title: "Phylogenetic signal"
output: pdf_document
---

```{r}
library(ggplot2)
library(reshape2)
library(dplyr)
library(ggpubr)
library(igraph)
library(EnvStats)
library(aricode)
library(vegan)
library(ade4)
library(ape)
library(tidyr)
library(ggraph)
library(cluster)    
library(fpc)  

source(here::here("code/functions/functions_simulation.R")) 
```

```{r}
my.theme<-theme(axis.text=element_text(size=12),
                axis.title = element_text(size = 14),
                legend.position = "top",
                legend.text=element_text(size=10),
                legend.title = element_text(size=12),
                plot.title = element_text(face="bold",size=14,margin=margin(0,0,20,0),hjust = 0.5),
                axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)),
                axis.title.x = element_text(margin = margin(t = 15, r = 0, b = 0, l = 0)))
```



Function to obtain the newick tree format from the ancestry tables

```{r}
ToPhylo2 <- function(data){
  data.2 <- data
  data.2$repr <- data$spp
  sisters <- levels(as.factor(data$spp))
  mothers <- levels(as.factor(data$ancestor))
  tips <- setdiff(sisters, mothers)
  root <- setdiff(mothers, sisters)
  
  # the root might be ancestor=0
  if(length(root) == 0) root <- 0
  foc.nodes <- unique(data[which(data$spp %in% tips), "ancestor"])
  n <- length(foc.nodes)
  data.2$repr[data.2$spp %in% tips] <- data.2$repr[data.2$spp %in% tips]
  
  while(n > 1){
    foc.nodes2 <- unique(data.2[which(data.2$spp %in% foc.nodes), "ancestor"])
    for(i in 1:n){
      daughters <- data.2[which(data.2$ancestor == foc.nodes[i]), "repr"]
      daughters.dist <- data.2[which(data.2$ancestor == foc.nodes[i]), "distance"]
      
      # This block handles the case where the ancestor is still extant (coexists with mutants)
      if(foc.nodes[i] %in% data.2$spp){
        daughters <- c(daughters, foc.nodes[i])
        daughters.dist <- c(daughters.dist, 0)  # Set ancestor's distance as 0
      }
      
      data.2$repr[data.2$spp == foc.nodes[i]] <- paste0(sister.group(daughters, daughters.dist), foc.nodes[i])
    }
    tips <- foc.nodes
    foc.nodes <- foc.nodes2
    n <- length(foc.nodes)
  }
  
  daughters <- data.2[which(data.2$ancestor == foc.nodes[1]), "repr"]
  daughters.dist <- data.2[which(data.2$ancestor == foc.nodes[1]), "distance"]
  
  paste0(sister.group(daughters, daughters.dist), root, ";")  # Ensuring the tree ends with a semicolon
}

```




Load results from 1 simulation (change file path as needed)

```{r}
res_sim <- readRDS(here::here("output/results_toplot_networks_timesteps.rds"))
```


#### Inspect simulation dynamics 

Load functions (change file path as needed)

```{r}
nsteps =  141
source(here::here("code/functions/functions_simulation_inspection.R"))
inspect_simulation_fw(simulation_data = res_sim, nbasals = 5, Smax = 1000)
```


## Function to compute distance matrices

Taking as input the results from the simulation, this function does the following:

1) Prepares data
- Identifies and removes timesteps where phylogenetic distances can't be computed.
- Converts species identifiers from numbers to letters for consistency.

2) Processes phylogenetic data:

- Constructs phylogenetic distance matrices for living species at each timestep.
- Ensures species consistency between phylogenetic and presence matrices.
- Egeinvectors of the cropped phylogenetic correlation matrix are computed using:
list_svd_eigen.phy[[i]] <- eigen(list_phylo.corr_cropped[[i]], symmetric = T)$vec

3) Processes interaction Data:

- Filters interaction matrices to include only present species.
- Performs Singular Value Decomposition (SVD) on interaction matrices and keeps the right singular vectors (predator roles of species). The transposed right singular vectors are kept.


It saves the computed eigenvectors from the phylogenetic correlation matricesand the ones from the interaction matrices. We will use this output to compute correlations between them.


```{r}
compute_dist_matrices <- function(results_simulation, int, Smax, nbasals) {
  
  presence_matrix <- results_simulation$presence_matrix
  
  # number of timesteps
  n_steps <- length(results_simulation$network_list)
  
  #### Identify timesteps where phylogenetic distances cant be calculated
  non.valid_timesteps_phylo_distance <- c(which(rowSums(presence_matrix) < 3))
  # until what timestep need to discard:
  final.discarded_timestep <- (non.valid_timesteps_phylo_distance[length(non.valid_timesteps_phylo_distance)])+1
  
  #### homogenize elements to start from valid timesteps
  # ancestry table
  list_anc_dist <- results_simulation$list_anc_dist[(final.discarded_timestep+1):length(results_simulation$list_anc_dist)]
  # network list
  network_list <- results_simulation$network_list[(final.discarded_timestep+1):length(results_simulation$list_anc_dist)]
  
  
  ## ------------------- Check
  if (length(which(is.null(results_simulation$network_list))) > 0) {
    print("PROBLEM - null network somewhere")
  } 
  if(length(list_anc_dist) != length(network_list)){
    print("PROBLEM - length list_anc_dist != length(network_list)")
  }
  ## -------------------
  
  
  
  if(int == "foodweb"){
    #### Eliminate basal species
    Sbasals <- nbasals
    network_list <- lapply(network_list, eliminate_basals, nbasals = Sbasals)
  }
  
  #### Convert spp names from numbers to letters
  ## ancestry-distances table
  list_anc_dist_letters <- lapply(list_anc_dist, change_sppnames_letters_ancdist.table)
  ## Network list 
  list_networks_sppnames_numbers <- lapply(network_list, set_sppNames_numbers)
  list_networks_sppnames_letters <- lapply(list_networks_sppnames_numbers, convert_sppnames_toletters)
  
  
  
  ## ------------------- Check
  if(length(list_anc_dist_letters) != length(list_networks_sppnames_letters)){
    print("PROBLEM - list_anc_dist_letters != list_networks_sppnames_letters")
  } 
  ## -------------------
  
  
  #### convert spp names to letters in presence matrix
  colnames(presence_matrix) <- seq(1:Smax)
  colnames(presence_matrix) <- chartr("0123456789", "ABCDEFGHIJ", colnames(presence_matrix))
  
  
  
  ## ------------------- Check
  
  if(length(which(colnames(presence_matrix) != colnames(list_networks_sppnames_letters[[1]]))) != 0){
    print("PROBLEM - spp names in presence_matrix dont correspond to spp names in list_networks_sppnames_letterst")
  }
  ## -------------------
  
  
  
  # Discard same timesteps (rows) than the discarted phylogenetic distance matrices
  presence_matrix <- presence_matrix[(final.discarded_timestep+1):length(results_simulation$list_anc_dist),]
  
  
  ## ------------------- Check
  
  if(nrow(presence_matrix) != length(list_networks_sppnames_letters)){
    print("PROBLEM - presence matrix, list phylo dist and list interaction networks dont have the same n_steps")
  }
  
  ## -------------------
  
  ## Loop for obtaining phylogenetic distances:
  list_svd_eigen.phy <- list()
  list_phylo.corr_cropped <- list()
  
  
  for (i in 1:length(list_anc_dist_letters)) {
    
    print(paste("step", i))
    
    # obtain phylogenetic distances between all tree nodes
    
    newick <- ToPhylo2(list_anc_dist_letters[[i]])
    newick_tail <- paste(newick, "root")
    tree <- read.tree(text = sub("A root",";",newick_tail))
    #list_dist.phylo[[i]] <- cophenetic.phylo(tree)
    
    tree$edge.length<-sapply(tree$edge.length,function(x) ifelse(x==0,1e-5,x))
    phylo.vcv<-vcv(tree)
    phylo.corr<-cov2cor(phylo.vcv)
    
    # Crop matrix of phylogenetic distances with those species that are alive
    
    # alive_species <- list_anc_dist_letters[[i]][which(list_anc_dist_letters[[i]]$`A/E` == "A"), "spp"]
    alive_species <- names(which(presence_matrix[i, ] == 1))
    list_phylo.corr_cropped[[i]] <- phylo.corr[alive_species, alive_species]
    
    # Check that species in the phylogenetic distance matrix are the same present in the presence matrix
    
    if (all(names(which(presence_matrix[i, ] == 1)) != colnames(list_phylo.corr_cropped[[i]]))) {
      cat("Species mismatch detected for index", i, "\n")
    }
    
    
    list_svd_eigen.phy[[i]] <-eigen(list_phylo.corr_cropped[[i]], symmetric = T)$vec
  }
  
  
  ## ------------------- Check
  if (length(which(unlist(lapply(list_svd_eigen.phy, is.null)) == TRUE)) != 0) {
    print("PROBLEM - nulls in list_dist.phylo")
  }
  if (length(list_svd_eigen.phy) != length(list_networks_sppnames_letters)){
    print("PROBLEM - length(list_dist.phylo) != length(list_networks_sppnames_letters)")
  }
  ## -------------------
  
  
  
  ## ------------------- Check
  #Check that phylogenetic distance matrices retain present species:
  vec_error <- c()
  for (i in 1:nrow(presence_matrix)) {
    vec_tf <-  names(presence_matrix[i, which(presence_matrix[i,] == 1)]) == colnames(list_svd_eigen.phy[[i]])
    if(length(which(vec_tf == FALSE)) > 0){
      vec_error[i] <- "error"
    } else if (length(which(vec_tf == FALSE)) == 0 ){
      vec_error[i] <- "g"
    }
  }
  if(length(which(vec_error == "error")) > 0){
    print("PROBLEM - list_dist.phylo_pres dont retain present species")
  }
  ## -------------------
  
  
  #### Retain only present species in network matrices
  list_net_present_spp.letters <- list()
  
  for (i in 1:length(list_networks_sppnames_letters)) {
    list_net_present_spp.letters[[i]] <- list_networks_sppnames_letters[[i]][names(which(presence_matrix[i,] == 1)), names(which(presence_matrix[i,] == 1))]
  }
  
  
  
  
  
  #############################################################################
  
  
  list_svd_pred <- list()
  
  for (i in 1:length(list_net_present_spp.letters)) {
    
    # Perform SVD
    svd_result <- svd(list_net_present_spp.letters[[i]])
    
    # Extract left (U), middle (D), and right (V) matrices
    U <- svd_result$u       # Left matrix (n_prey x kept axes)
    D <- diag(svd_result$d) # Middle matrix (kept axes x kept axes)
    V <- svd_result$v       # Right matrix (n_predators x kept axes)
    
    # Decide on the number of axes to keep
    kept_axes <- ncol(list_net_present_spp.letters[[i]])  
    
    # Select the kept axes from U, D, and V
    U_kept <- U[, 1:kept_axes]   # n_prey x kept axes
    D_kept <- D[1:kept_axes, 1:kept_axes] # kept axes x kept axes
    V_kept <- V[, 1:kept_axes]   # n_predators x kept axes
    
    # Transpose the right matrix V to match the desired output
    list_svd_pred[[i]] <- t(V_kept)  
    
  }
  
  
  
  ## ------------------- Check
  if(length(list_svd_pred) != length(list_svd_eigen.phy)){
    print("PROBLEM - length(list_interact_distances_mean_corrected) != length(list_dist.phylo_pres")
  }
  if(length(list_svd_eigen.phy) != length(list_svd_pred)) {
    print("PROBLEM - list phylo dist and lists interact dist dont have the same length")
  } 
  
  vec_problems_ncol <- c()
  
  for (i in 1:length(list_svd_pred)) {
    if(ncol(list_svd_pred[[i]]) != ncol(list_svd_eigen.phy[[i]])){
      vec_problems_ncol[i] <- "P"
    } else if(ncol(list_svd_pred[[i]]) == ncol(list_svd_eigen.phy[[i]])){
      vec_problems_ncol[i] <- "g"
    }
  }
  if(length(which(vec_problems_ncol == "P") > 0)){
    print("PROBLEM - Interact and phylo dist. matrices dont have the same ncols")
  }
  
  vec_problems_sppcomp <- c()
  
  for (i in 1:length(list_svd_eigen.phy)) {
    vec_problems_sppcomp[i] <- identical(sort(colnames(list_svd_pred[[i]])), sort(colnames(list_svd_eigen.phy[[i]])))
  }
  if(length(which(vec_problems_ncol == "FALSE") > 0)){
    print("PROBLEM -  Interact and phylo dist. matrices dont have the order of colnames")
  }
  
  vec_problems <- c()
  
  for (i in 1:length(list_svd_pred)) {
    vec_truefalse <- colnames(list_svd_pred[[i]]) == colnames(list_svd_eigen.phy[[i]])
    if(FALSE %in% vec_truefalse){
      vec_problems[i] <- "P"
    }else{
      vec_problems[i] <- "_"
    }
  }
  if(length(which(vec_problems == "P") > 0)){
    print("PROBLEM - Interact and phylo dist. matrices dont have the same order of colnames")
  }
  
  
  
  result <- list("list_svd_pred" = list_svd_pred,
                 "list_svd_eigen.phy" = list_svd_eigen.phy,
                 "list_net_present_spp.letters" = list_net_present_spp.letters,
                 "list_phylo.corr_cropped" = list_phylo.corr_cropped)
  
  return(result)
}


```


```{r}
sdv_matrices <- compute_dist_matrices(results_simulation = res_sim,
    		                       int = "foodweb",
    		                      Smax = 1000,
    		                      nbasals = 5)

list_svd_pred <- sdv_matrices$list_svd_pred
list_svd_eigen.phy <- sdv_matrices$list_svd_eigen.phy

list_network <- sdv_matrices$list_net_present_spp.letters
list_corrphylo <- sdv_matrices$list_phylo.corr_cropped
```



# Method 1 - Procrustes correlation 


## 1.1. Procrustes using only the 6 first axes


```{r}

timestep <- vector()
S <- vector()
cor <- vector()
kept_axes <- 6  # Number of axes to keep if S > 6

# Loop through each timestep to compute Procrustes correlations
for (i in seq_along(list_svd_pred)) {
  
  # Get the number of species (community size) at this timestep
  current_S <- ncol(list_svd_pred[[i]])
  
  # Determine the number of axes to keep
  if (current_S <= kept_axes) {
    # Keep all axes if S is less than or equal to 6
    svd_pred_kept <- list_svd_pred[[i]]
    svd_phy_kept <- list_svd_eigen.phy[[i]]
  } else {
    # Keep only 6 axes if S is greater than 6
    svd_pred_kept <- list_svd_pred[[i]][, 1:kept_axes]
    svd_phy_kept <- list_svd_eigen.phy[[i]][, 1:kept_axes]
  }
  
  # Run Procrustes analysis on the selected axes
  proc <- protest(svd_pred_kept, svd_phy_kept)
  
  # Store results
  timestep[i] <- i
  S[i] <- current_S  # Number of species (community size)
  cor[i] <- proc$t0
}

# Create a dataframe to store results
df_results <- data.frame(timestep = timestep, 
                         S = S, 
                         cor = cor)

ggarrange(
  
  # Plot the correlation along community size S
ggplot(df_results, aes(x = timestep, y = cor)) +
  geom_point(alpha = 0.5) +  # Add transparency to the points
  #geom_smooth(method = "gam", formula = y ~ s(x), se = TRUE) +  # Add GAM smooth line with confidence interval
  labs(x = "Time Steps", y = "Phylogenetic signal") +
  theme_classic() +
  ylim(0, 1),


  ggplot(df_results, aes(x = S, y = cor)) +
  geom_point(alpha = 0.5) +  # Add transparency to the points
  #geom_smooth(method = "gam", formula = y ~ s(x), se = TRUE) +  # Add GAM smooth line with confidence interval
  labs(x = "Species richness", y = "Phylogenetic signal") +
  theme_classic() +
  ylim(0, 1),

ncol = 2, 
nrow = 1
  
)

```


## test if size drives this relationship


```{r}
set.seed(123)  # Ensure reproducibility

# Initialize vectors to store results
timestep <- vector()
S <- vector()
cor_observed <- vector()
cor_shuffled <- vector()
kept_axes <- 6  # Number of axes to keep if S > 6
num_permutations <- 5  # Number of shuffling iterations

# Loop through each timestep to compute Procrustes correlations
for (i in seq_along(list_svd_pred)) {
  
  # Get the number of species (community size) at this timestep
  current_S <- ncol(list_svd_pred[[i]])
  
  # Determine the number of axes to keep
  if (current_S <= kept_axes) {
    svd_pred_kept <- list_svd_pred[[i]]
    svd_phy_kept <- list_svd_eigen.phy[[i]]
  } else {
    svd_pred_kept <- list_svd_pred[[i]][, 1:kept_axes]
    svd_phy_kept <- list_svd_eigen.phy[[i]][, 1:kept_axes]
  }
  
  # Compute observed Procrustes correlation
  proc_observed <- protest(svd_pred_kept, svd_phy_kept)
  
  # Store observed correlation
  timestep[i] <- i
  S[i] <- current_S  # Number of species (community size)
  cor_observed[i] <- proc_observed$t0
  
  # Generate shuffled correlation values
  cor_shuffled_replicates <- numeric(num_permutations)
  
  for (j in 1:num_permutations) {
    # Shuffle the phylogenetic matrix columns randomly
    shuffled_phy <- svd_phy_kept[sample(nrow(svd_phy_kept)), ]
    
    # Run Procrustes analysis on shuffled data
    proc_shuffled <- protest(svd_pred_kept, shuffled_phy)
    cor_shuffled_replicates[j] <- proc_shuffled$t0
  }
  
  # Store the average of shuffled correlations
  cor_shuffled[i] <- mean(cor_shuffled_replicates)
}

# Create a dataframe to store results
df_results <- data.frame(timestep = timestep, 
                         S = S, 
                         cor_observed = cor_observed,
                         cor_shuffled = cor_shuffled)

# Plot observed vs shuffled Procrustes correlation over time
ggplot(df_results, aes(x = timestep)) +
  geom_point(aes(y = cor_observed), color = "blue", alpha = 0.5) + 
  geom_point(aes(y = cor_shuffled), color = "red", alpha = 0.5) + 
  labs(x = "Time Steps", y = "Procrustes Correlation", 
       title = "Observed vs. Shuffled Procrustes Correlations") +
  theme_classic() +
  ylim(0, 1) +
  scale_color_manual(values = c("blue" = "Observed", "red" = "Shuffled"))

# Plot observed and shuffled correlation as a function of species richness
ggplot(df_results, aes(x = S)) +
  geom_point(aes(y = cor_observed), color = "blue", alpha = 0.5) + 
  geom_point(aes(y = cor_shuffled), color = "red", alpha = 0.5) + 
  labs(x = "Species Richness", y = "Procrustes Correlation", 
       title = "Effect of Species Richness on Procrustes Correlations") +
  theme_classic() +
  ylim(0, 1)

```

Procrustes correlations is totally influenced by the size of the matrix, even if only keeping the 6 first dimensions of all matrices. 


## 1.2. Procrustes correlation with optimized number of axes

```{r}
# Initialize vectors to store results
timestep <- vector()
S <- vector()
cor <- vector()
d_phylo <- vector()
d_network <- vector()
threshold <- 0.9  # Threshold for explained variance (e.g., 90%)

# Loop through each timestep to compute Procrustes correlations
for (i in seq_along(list_svd_pred)) {
  
  # Extract singular values from the original SVD for the interaction matrix
  svd_result <- svd(list_network[[i]])
  singular_values <- svd_result$d
  
  # Compute cumulative explained variance for the interaction matrix
  cum_var_pred <- cumsum(singular_values^2) / sum(singular_values^2)
  
  # Compute cumulative explained variance for the phylogenetic matrix
  eigenvalues_phy <- eigen(list_corrphylo[[i]], symmetric = TRUE)$values
  cum_var_phy <- cumsum(eigenvalues_phy) / sum(eigenvalues_phy)
  
  # Determine the number of axes needed to reach the threshold (90% variance)
  num_axes_pred <- min(which(cum_var_pred >= threshold))
  num_axes_phy <- min(which(cum_var_phy >= threshold))
  
  # Store the number of dimensions retained for each matrix
  d_network[i] <- num_axes_pred
  d_phylo[i] <- num_axes_phy
  
  # Decide on the number of axes to keep: the maximum of the two
  num_axes_to_keep <- max(num_axes_pred, num_axes_phy)
  
  # Adjust matrices to keep only the necessary axes
  svd_pred_kept <- list_svd_pred[[i]][, 1:num_axes_to_keep]
  svd_phy_kept <- list_svd_eigen.phy[[i]][, 1:num_axes_to_keep]
  
  # Run Procrustes analysis on the selected axes
  proc <- protest(svd_pred_kept, svd_phy_kept)
  
  # Store results
  timestep[i] <- i
  S[i] <- ncol(list_svd_pred[[i]])  # Number of species (community size)
  cor[i] <- proc$t0
}

# Create a dataframe to store results
df_results <- data.frame(timestep = timestep, 
                         S = S, 
                         cor = cor,
                         d_phylo = d_phylo,
                         d_network = d_network)

# Plot the correlation along community size S
ggplot(df_results, aes(x = timestep, y = cor)) +
  geom_point(alpha = 0.5) + # Plot points for the correlation
 # geom_smooth(method = "gam", formula = y ~ s(x)) + # Add GAM smooth line
  labs(x = "Time steps", y = "Phylogenetic signal") +
  theme_classic() +
  ylim(0,1)
```


Plot the dimensions retained for phylogenetic and network matrices:

```{r}

df_long <- reshape2::melt(df_results, id.vars = "timestep", measure.vars = c("d_phylo", "d_network"),
                          variable.name = "Dimension_Type", value.name = "Dimensions")

ggplot(df_long, aes(x = timestep, y = Dimensions, color = Dimension_Type)) +
  geom_point() +
  geom_line() +
  labs(x = "timestep", y = "Number of Dimensions Retained",
       color = "Dimension Type") +
  theme_classic() +
  scale_color_manual(values = c("d_phylo" = "blue", "d_network" = "red"))
```


Now testing different % of variance retained

```{r}


# Initialize storage lists for all thresholds
thresholds <- c(0.7, 0.8, 0.9)
df_list <- list()

for (threshold in thresholds) {
  # Initialize vectors to store results
  timestep <- vector()
  d_phylo <- vector()
  d_network <- vector()

  for (i in seq_along(list_svd_pred)) {

    # Extract singular values from the SVD for the interaction matrix
    svd_result <- svd(list_network[[i]])
    singular_values <- svd_result$d

    # Compute cumulative explained variance for the interaction matrix
    cum_var_pred <- cumsum(singular_values^2) / sum(singular_values^2)

    # Compute cumulative explained variance for the phylogenetic matrix
    eigenvalues_phy <- eigen(list_corrphylo[[i]], symmetric = TRUE)$values
    cum_var_phy <- cumsum(eigenvalues_phy) / sum(eigenvalues_phy)

    # Determine the number of axes needed to reach the threshold
    num_axes_pred <- min(which(cum_var_pred >= threshold))
    num_axes_phy <- min(which(cum_var_phy >= threshold))

    # Store dimensions retained for both matrices
    timestep[i] <- i
    d_network[i] <- num_axes_pred
    d_phylo[i] <- num_axes_phy
  }

  # Store the results in a dataframe with threshold label
  df_temp <- data.frame(
    timestep = timestep,
    d_phylo = d_phylo,
    d_network = d_network,
    threshold = as.factor(paste0(threshold * 100, "%"))
  )
  df_list[[as.character(threshold)]] <- df_temp
}

# Combine all threshold results
df_combined <- do.call(rbind, df_list)

# Reshape to long format for ggplot
df_long <- reshape2::melt(df_combined, id.vars = c("timestep", "threshold"),
                          measure.vars = c("d_phylo", "d_network"),
                          variable.name = "Dimension_Type",
                          value.name = "Dimensions")

ggplot(df_long, aes(x = timestep, y = Dimensions, color = threshold, linetype = Dimension_Type)) +
#  geom_point(alpha = 0.6) + 
  geom_smooth(se = FALSE, method = "loess", span = 0.3, alpha = 0.8) +  # Smooths the trend between points
  labs(
    x = "Time step",
    y = "Number of dimensions retained",
    color = "Variance threshold",
    linetype = "Matrix type"
  ) +
  theme_classic() +
  scale_color_manual(values = c("#E41A1C", "#377EB8", "#4DAF4A")) +  # Colors for different variance thresholds
  scale_linetype_manual(values = c("d_phylo" = "dashed", "d_network" = "solid"))



```

```{r}

# Initialize storage for variance explained across timesteps
variance_explained_list <- list()

for (i in seq_along(list_svd_pred)) {
  
  # Extract singular values from the original SVD for the interaction matrix
  svd_result <- svd(list_network[[i]])
  singular_values <- svd_result$d
  
  # Compute percentage of variance explained by each dimension
  var_explained_network <- (singular_values^2) / sum(singular_values^2) * 100

  # Extract eigenvalues for the phylogenetic matrix
  eigenvalues_phy <- eigen(list_corrphylo[[i]], symmetric = TRUE)$values
  var_explained_phylo <- (eigenvalues_phy) / sum(eigenvalues_phy) * 100
  
  # Store results in a dataframe for this timestep
  df_temp <- data.frame(
    Dimension = seq_along(var_explained_network),
    Variance_Explained = c(var_explained_network, var_explained_phylo),
    Matrix_Type = rep(c("Network", "Phylogeny"), times = c(length(var_explained_network), length(var_explained_phylo)))
  )

  # Append to list
  variance_explained_list[[i]] <- df_temp
}

# Combine results across all timesteps
df_variance_explained <- do.call(rbind, variance_explained_list)

# Histogram Plot of Variance Explained
ggplot(df_variance_explained, aes(x = Variance_Explained, fill = Matrix_Type)) +
  geom_histogram(binwidth = 5, alpha = 0.3, position = "identity") +
  labs(
    x = "Variance Explained (%)",
    y = "Frequency",
    fill = "Matrix Type"
  ) +
  theme_classic() +
  scale_fill_manual(values = c("Network" = "red", "Phylogeny" = "blue"))

```



# Method 2 - Mantel correlation between network and phylogenetic egeinvectors


## 2.1 - using all axes

```{r}
# Initialize vectors to store results
timestep <- vector()
S <- vector()
cor_mantel <- vector()

# Loop through each timestep to compute Mantel correlations
for (i in seq_along(list_svd_pred)) {
  
  # Extract SVD results for prediction and phylogenetic matrices
  svd_pred <- list_svd_pred[[i]]
  svd_phy <- list_svd_eigen.phy[[i]]
  
  # Compute pairwise Euclidean distance matrices for both
   dist_pred <- dist(svd_pred)
   dist_phy <- dist(svd_phy)
  
  
  # Run Mantel test to compare the two distance matrices
  mantel_result <- mantel(dist_phy, dist_pred, permutations = 999)
  
  # Store results
  timestep[i] <- i
  S[i] <- ncol(list_svd_pred[[i]])  # Number of species (community size)
  cor_mantel[i] <- mantel_result$statistic  # Mantel correlation coefficient
}

df_mantel_results <- data.frame(timestep = timestep, 
                                S = S, 
                                cor_mantel = cor_mantel)

ggplot(df_mantel_results, aes(x = timestep, y = cor_mantel)) +
  geom_point(alpha = 0.5) +  
  labs(x = "Time Steps", y = "Mantel Correlation") +
  theme_classic() +
  #geom_vline(xintercept = I_max, linetype = "dashed") +
  ylim(0, 1)
```


## 2.2 Manel corr between optimized axes


```{r}
# Initialize vectors to store results
timestep <- vector()
S <- vector()
cor <- vector()
d_phylo <- vector()
d_network <- vector()
threshold <- 0.7  # Threshold for explained variance (e.g., 90%)

# Loop through each timestep to compute Procrustes correlations
for (i in seq_along(list_svd_pred)) {

  # Extract singular values from the original SVD for the interaction matrix
  svd_result <- svd(list_network[[i]])
  singular_values <- svd_result$d

  # Compute cumulative explained variance for the interaction matrix
  cum_var_pred <- cumsum(singular_values^2) / sum(singular_values^2)

  # Compute cumulative explained variance for the phylogenetic matrix
  eigenvalues_phy <- eigen(list_corrphylo[[i]], symmetric = TRUE)$values
  cum_var_phy <- cumsum(eigenvalues_phy) / sum(eigenvalues_phy)

  # Determine the number of axes needed to reach the threshold (90% variance)
  num_axes_pred <- min(which(cum_var_pred >= threshold))
  num_axes_phy <- min(which(cum_var_phy >= threshold))

  # Store the number of dimensions retained for each matrix
  d_network[i] <- num_axes_pred
  d_phylo[i] <- num_axes_phy

  # Decide on the number of axes to keep: the maximum of the two
  num_axes_to_keep <- max(num_axes_pred, num_axes_phy)

  # Adjust matrices to keep only the necessary axes
  svd_pred_kept <- list_svd_pred[[i]][, 1:num_axes_to_keep]
  svd_phy_kept <- list_svd_eigen.phy[[i]][, 1:num_axes_to_keep]

     dist_pred <- dist(svd_pred_kept)
   dist_phy <- dist(svd_phy_kept)

  # Run Procrustes analysis on the selected axes
  mantel_result <- mantel(dist_phy, dist_pred, permutations = 999)

   # Store results
  timestep[i] <- i
  S[i] <- ncol(list_svd_pred[[i]])  # Number of species (community size)
  cor[i] <- mantel_result$statistic  # Mantel correlation coefficient
}


df_results <- data.frame(timestep = timestep,
                                S = S,
                                cor_mantel = cor,
                         d_phylo = d_phylo,
                         d_network = d_network)

# Plot the Mantel correlation along time steps
ggplot(df_results, aes(x = timestep, y = cor_mantel)) +
  geom_point(alpha = 0.5) +
  geom_smooth(se = FALSE, method = "loess", span = 0.3, alpha = 0.8)+
  labs(x = "Time Steps", y = "Mantel Correlation") +
  theme_classic() +
  ylim(0, 1)


```



Multiple scenarios of variance expained

```{r}

# Initialize storage lists for different variance thresholds
thresholds <- c(0.7, 0.8, 0.9)
df_list <- list()

# Loop through different variance thresholds
for (threshold in thresholds) {
  
  # Initialize vectors for results
  timestep <- vector()
  d_phylo <- vector()
  d_network <- vector()
  cor_mantel <- vector()
  
  # Loop through each timestep
  for (i in seq_along(list_svd_pred)) {
    
    # Extract singular values from the SVD for the interaction matrix
    svd_result <- svd(list_network[[i]])
    singular_values <- svd_result$d
    
    # Compute cumulative explained variance for the interaction matrix
    cum_var_pred <- cumsum(singular_values^2) / sum(singular_values^2)
    
    # Compute cumulative explained variance for the phylogenetic matrix
    eigenvalues_phy <- eigen(list_corrphylo[[i]], symmetric = TRUE)$values
    cum_var_phy <- cumsum(eigenvalues_phy) / sum(eigenvalues_phy)
    
    # Determine the number of axes needed to reach the threshold
    num_axes_pred <- min(which(cum_var_pred >= threshold))
    num_axes_phy <- min(which(cum_var_phy >= threshold))
    
    # Store dimensions retained for both matrices
    d_network[i] <- num_axes_pred
    d_phylo[i] <- num_axes_phy
    
    # Decide on the number of axes to keep (maximum of both)
    num_axes_to_keep <- max(num_axes_pred, num_axes_phy)
    
    # Adjust matrices to keep only the necessary axes
    svd_pred_kept <- list_svd_pred[[i]][, 1:num_axes_to_keep]
    svd_phy_kept <- list_svd_eigen.phy[[i]][, 1:num_axes_to_keep]
    
    # Compute Euclidean distance matrices
    dist_pred <- dist(svd_pred_kept)
    dist_phy <- dist(svd_phy_kept)
    
    # Run Mantel test
    mantel_result <- mantel(dist_phy, dist_pred, permutations = 999)
    
    # Store results
    timestep[i] <- i
    cor_mantel[i] <- mantel_result$statistic  # Mantel correlation coefficient
  }
  
  # Store results in a dataframe with threshold label
  df_temp <- data.frame(
    timestep = timestep,
    d_phylo = d_phylo,
    d_network = d_network,
    cor_mantel = cor_mantel,
    threshold = as.factor(paste0(threshold * 100, "%"))
  )
  
  df_list[[as.character(threshold)]] <- df_temp
}

# Combine all threshold results
df_combined <- do.call(rbind, df_list)

# Reshape to long format for ggplot
df_long <- melt(df_combined, id.vars = c("timestep", "threshold"),
                measure.vars = c("d_phylo", "d_network"),
                variable.name = "Dimension_Type",
                value.name = "Dimensions")

# Plot the number of dimensions retained across timesteps
ggplot(df_long, aes(x = timestep, y = Dimensions, color = threshold, linetype = Dimension_Type)) +
  geom_smooth(se = FALSE, method = "loess", span = 0.3, alpha = 0.8) +  # Smooth trends
  labs(
    x = "Time step",
    y = "Number of dimensions retained",
    color = "Variance threshold",
    linetype = "Matrix type"
  ) +
  theme_classic() +
  scale_color_manual(values = c("#E41A1C", "#377EB8", "#4DAF4A")) +  # Colors for different thresholds
  scale_linetype_manual(values = c("d_phylo" = "dashed", "d_network" = "solid"))

```




```{r}
ggplot(df_combined, aes(x = timestep, y = cor_mantel, color = threshold)) +
  geom_smooth(se = FALSE, method = "loess", span = 0.3, alpha = 0.8) +  # Smooth trend
  labs(
    x = "Time Steps",
    y = "Mantel Correlation",
    color = "Variance Threshold"
  ) +
  theme_classic() +
  scale_color_manual(values = c("#E41A1C", "#377EB8", "#4DAF4A"))

```

```{r}
# Initialize storage for variance explained across timesteps
variance_explained_list <- list()

for (i in seq_along(list_svd_pred)) {
  
  # Extract singular values from the SVD for the interaction matrix
  svd_result <- svd(list_network[[i]])
  singular_values <- svd_result$d
  
  # Compute percentage of variance explained by each dimension
  var_explained_network <- (singular_values^2) / sum(singular_values^2) * 100
  
  # Extract eigenvalues for the phylogenetic matrix
  eigenvalues_phy <- eigen(list_corrphylo[[i]], symmetric = TRUE)$values
  var_explained_phylo <- (eigenvalues_phy) / sum(eigenvalues_phy) * 100
  
  # Store results in a dataframe for this timestep
  df_temp <- data.frame(
    Dimension = seq_along(var_explained_network),
    Variance_Explained = c(var_explained_network, var_explained_phylo),
    Matrix_Type = rep(c("Network", "Phylogeny"), times = c(length(var_explained_network), length(var_explained_phylo)))
  )
  
  # Append to list
  variance_explained_list[[i]] <- df_temp
}

# Combine results across all timesteps
df_variance_explained <- do.call(rbind, variance_explained_list)

# Histogram Plot of Variance Explained
ggplot(df_variance_explained, aes(x = Variance_Explained, fill = Matrix_Type)) +
  geom_histogram(binwidth = 5, alpha = 0.3, position = "identity") +
  labs(
    x = "Variance Explained (%)",
    y = "Frequency",
    fill = "Matrix Type"
  ) +
  theme_classic() +
  scale_fill_manual(values = c("Network" = "red", "Phylogeny" = "blue"))

```



## Test the effect of network size on Mantel results

I compare the results with those obtained from shuffled matrices to test whether the relationship I observe is only due to the size of the matrices (it may be that the more size, the more difficult to have high correlations).


```{r}
# Function to shuffle matrix values while keeping the structure
shuffle_matrix <- function(matrix) {
  shuffled_values <- sample(as.vector(matrix))  # Shuffle all values
  shuffled_matrix <- matrix(shuffled_values, nrow = nrow(matrix), ncol = ncol(matrix))
  return(shuffled_matrix)
}


timestep <- vector()
S <- vector()
cor_mantel_original <- vector()
cor_mantel_shuffled <- vector()

set.seed(123)

# Mantel correlations for both original and shuffled matrices
for (i in seq_along(list_svd_pred)) {
  
  # Original matrices
  svd_pred <- list_svd_pred[[i]]
  svd_phy <- list_svd_eigen.phy[[i]]
  
 # Compute distance for original matrices
  dist_pred <- dist(svd_pred)
  dist_phy <- dist(svd_phy)
  
  # Run Mantel test for original matrices
  mantel_result_orig <- mantel(dist_phy, dist_pred, permutations = 999)
  
  # Shuffle matrices
  svd_pred_shuffled <- shuffle_matrix(svd_pred)
  svd_phy_shuffled <- shuffle_matrix(svd_phy)
  
  # Compute distance for shuffled matrices
  dist_pred_shuffled <- dist(svd_pred_shuffled)
  dist_phy_shuffled <- dist(svd_phy_shuffled)
  
  # Run Mantel test for shuffled matrices
  mantel_result_shuffled <- mantel(dist_phy_shuffled, dist_pred_shuffled, permutations = 999)
  
  # store results
  timestep[i] <- i
  S[i] <- ncol(list_svd_pred[[i]])  
  cor_mantel_original[i] <- mantel_result_orig$statistic 
  cor_mantel_shuffled[i] <- mantel_result_shuffled$statistic  
}

# dataframe to store results
df_mantel_results <- data.frame(
  timestep = timestep, 
  S = S, 
  cor_mantel_original = cor_mantel_original,
  cor_mantel_shuffled = cor_mantel_shuffled
)

# Mantel correlation over time for original vs shuffled matrices
ggplot(df_mantel_results, aes(x = timestep)) +
  geom_point(aes(y = cor_mantel_original, color = "Original"), alpha = 0.5) +
  geom_point(aes(y = cor_mantel_shuffled, color = "Shuffled"), alpha = 0.5) +
  labs(x = "Time Steps", y = "Mantel Correlation", color = "Matrix Type") +
  theme_classic() +
  ylim(0, 1) +
  theme(legend.position = "top")

```

Seems to be the case that the size is driving the pattern, not the fact that the niche is being filled. Or at least I cannot say this is not the case.


# Method 3 - compare clusters


```{r}
compute_optimal_cluster_metrics <- function(results_simulation, Smax, nbasals) {
  
  presence_matrix <- results_simulation$presence_matrix
  
  # Number of timesteps
  n_steps <- length(results_simulation$network_list)
  
  # Identify valid timesteps
  non.valid_timesteps_phylo_distance <- which(rowSums(presence_matrix) < 3)
  final.discarded_timestep <- ifelse(length(non.valid_timesteps_phylo_distance) > 0, 
                                     max(non.valid_timesteps_phylo_distance) + 1, 1)
  
  list_anc_dist <- results_simulation$list_anc_dist[(final.discarded_timestep + 1):n_steps]
  network_list <- results_simulation$network_list[(final.discarded_timestep + 1):n_steps]
  
  # Convert species names to letters
  list_anc_dist_letters <- lapply(list_anc_dist, change_sppnames_letters_ancdist.table)
  list_networks_sppnames_numbers <- lapply(network_list, set_sppNames_numbers)
  list_networks_sppnames_letters <- lapply(list_networks_sppnames_numbers, convert_sppnames_toletters)
  
  colnames(presence_matrix) <- seq(1:Smax)
  colnames(presence_matrix) <- chartr("0123456789", "ABCDEFGHIJ", colnames(presence_matrix))
  
  presence_matrix <- presence_matrix[(final.discarded_timestep + 1):n_steps, ]
  
  # Store results
  ari_values <- numeric(length(list_networks_sppnames_letters))
  nmi_values <- numeric(length(list_networks_sppnames_letters))
  
  for (i in seq_along(list_anc_dist_letters)) {
    
    cat("Processing timestep:", i, "\n")
    
    # Process phylogenetic correlation matrix
    newick <- ToPhylo2(list_anc_dist_letters[[i]])
    newick_tail <- paste(newick, "root")
    tree <- read.tree(text = sub("A root",";", newick_tail))
    
    tree$edge.length <- sapply(tree$edge.length, function(x) ifelse(x == 0, 1e-5, x))
    phylo.vcv <- vcv(tree)
    phylo.corr <- cov2cor(phylo.vcv)
    
    alive_species <- names(which(presence_matrix[i, ] == 1))
    phylo_corr_cropped <- phylo.corr[alive_species, alive_species]
    
    # Clustering interaction matrix using SBM
    interaction_matrix <- list_networks_sppnames_letters[[i]][alive_species, alive_species]
    
    diag(interaction_matrix) <- 0  
    
    if (sum(interaction_matrix) == 0) {
      cat("Sparse or empty interaction matrix at timestep:", i, "- Assigning all species to one cluster.\n")
      interaction_clusters <- rep(1, nrow(interaction_matrix))
    } else {
      sbm_fit <- sbm::estimateSimpleSBM(interaction_matrix, model = "bernoulli")
      interaction_clusters <- sbm_fit$memberships
    }
    
    
    
    # Clustering phylogeny using k-means with automatic cluster number selection (gap statistic)
    phylo_dist <- as.dist(1 - phylo_corr_cropped)
    num_species <- nrow(phylo_corr_cropped)
    
    if (num_species > 2) {
      max_k <- min(4, num_species - 1)
      
      set.seed(123)
      gap_stat <- tryCatch({
        result <- clusGap(phylo_corr_cropped, FUN = kmeans, K.max = max_k, B = 50, verbose = FALSE)
        if (is.null(result) || !is.list(result) || !("Tab" %in% names(result))) NULL else result
      }, error = function(e) {
        cat("Gap statistic failed at timestep:", i, "- Assigning all species to a single cluster.\n")
        NULL
      })
      
      if (!is.null(gap_stat) && is.matrix(gap_stat$Tab)) {
        optimal_k <- which.max(gap_stat$Tab[, "gap"])
        phylo_clusters <- kmeans(phylo_corr_cropped, centers = max(2, optimal_k), nstart = 25)$cluster
      } else {
        phylo_clusters <- rep(1, num_species)
      }
      
    } else {
      phylo_clusters <- rep(1, num_species)
    }
    
    # Compare clusters using ARI and NMI
    ari_values[i] <- compare(interaction_clusters, phylo_clusters, method = "adjusted.rand")
    nmi_values[i] <- compare(interaction_clusters, phylo_clusters, method = "nmi")
  }
  
  
  return(data.frame(
    timestep = 1:length(ari_values),
    ARI = ari_values,
    NMI = nmi_values
  ))
}

```



```{r}
# Run the function with appropriate inputs
cluster_results <- compute_optimal_cluster_metrics(results_simulation = res_sim, 
                                                   Smax = 1000, 
                                                   nbasals = 5)

cluster_results <- compute_optimal_cluster_metrics_spectral(results_simulation = res_sim, 
                                                   Smax = 1000, 
                                                   nbasals = 5)
```

```{r}
ggplot(cluster_results, aes(x = timestep)) +
  geom_point(aes(y = ARI), color = 'blue', alpha = 0.7, size = 3) +
  geom_line(aes(y = ARI), color = 'blue') +
  geom_point(aes(y = NMI), color = 'red', alpha = 0.7, size = 3) +
  geom_line(aes(y = NMI), color = 'red') +
  labs(x = "Time Step", y = "Clustering Metrics", 
       title = "ARI and NMI Over Time") +
  theme_minimal() +
  scale_y_continuous(limits = c(0, 1), name = "Metric Value") +
  scale_x_continuous(name = "Time Step")+
  theme(legend.position = "right")
```

```{r}
library(igraph)

compute_optimal_cluster_metrics_spectral <- function(results_simulation, Smax, nbasals) {
  
  presence_matrix <- results_simulation$presence_matrix
  
  # Number of timesteps
  n_steps <- length(results_simulation$network_list)
  
  # Identify valid timesteps
  non.valid_timesteps_phylo_distance <- which(rowSums(presence_matrix) < 3)
  final.discarded_timestep <- ifelse(length(non.valid_timesteps_phylo_distance) > 0, 
                                     max(non.valid_timesteps_phylo_distance) + 1, 1)
  
  list_anc_dist <- results_simulation$list_anc_dist[(final.discarded_timestep + 1):n_steps]
  network_list <- results_simulation$network_list[(final.discarded_timestep + 1):n_steps]
  
  # Convert species names to letters
  list_anc_dist_letters <- lapply(list_anc_dist, change_sppnames_letters_ancdist.table)
  list_networks_sppnames_numbers <- lapply(network_list, set_sppNames_numbers)
  list_networks_sppnames_letters <- lapply(list_networks_sppnames_numbers, convert_sppnames_toletters)
  
  colnames(presence_matrix) <- seq(1:Smax)
  colnames(presence_matrix) <- chartr("0123456789", "ABCDEFGHIJ", colnames(presence_matrix))
  
  presence_matrix <- presence_matrix[(final.discarded_timestep + 1):n_steps, ]
  
  # Store results
  ari_values <- numeric(length(list_networks_sppnames_letters))
  nmi_values <- numeric(length(list_networks_sppnames_letters))
  
  for (i in seq_along(list_anc_dist_letters)) {
    
    cat("Processing timestep:", i, "\n")
    
    # Process phylogenetic correlation matrix
    newick <- ToPhylo2(list_anc_dist_letters[[i]])
    newick_tail <- paste(newick, "root")
    tree <- read.tree(text = sub("A root",";", newick_tail))
    
    tree$edge.length <- sapply(tree$edge.length, function(x) ifelse(x == 0, 1e-5, x))
    phylo.vcv <- vcv(tree)
    phylo.corr <- cov2cor(phylo.vcv)
    
    alive_species <- names(which(presence_matrix[i, ] == 1))
    phylo_corr_cropped <- phylo.corr[alive_species, alive_species]
    
    # Clustering interaction matrix using SBM
    interaction_matrix <- list_networks_sppnames_letters[[i]][alive_species, alive_species]
    
    diag(interaction_matrix) <- 0  
    
    if (sum(interaction_matrix) == 0) {
      cat("Sparse or empty interaction matrix at timestep:", i, "- Assigning all species to one cluster.\n")
      interaction_clusters <- rep(1, nrow(interaction_matrix))
    } else {
      sbm_fit <- sbm::estimateSimpleSBM(interaction_matrix, model = "bernoulli")
      interaction_clusters <- sbm_fit$memberships
    }
    
    # **Spectral Clustering for Phylogeny**
    num_species <- nrow(phylo_corr_cropped)
    
    if (num_species > 2) {
      
      # Convert correlation matrix into an adjacency matrix (similarity graph)
      adjacency_matrix <- abs(phylo_corr_cropped) # Ensuring positive similarities
      diag(adjacency_matrix) <- 0  # Remove self-connections
      
      # Compute the degree matrix
      degree_matrix <- diag(rowSums(adjacency_matrix))
      
      # Compute the Laplacian matrix
      laplacian_matrix <- degree_matrix - adjacency_matrix
      
      # Eigendecomposition of the Laplacian matrix
      eigen_decomp <- eigen(laplacian_matrix, symmetric = TRUE)
      
      # Choose the number of clusters (like k-means, but here using spectral properties)
      max_k <- min(4, num_species - 1)
      
      optimal_k <- max_k  # Default in case of failure
      
      # If eigenvalues suggest a good cutoff, use them
      if (!is.null(eigen_decomp$values)) {
        eigengap <- diff(eigen_decomp$values)
        optimal_k <- which.max(eigengap) + 1
      }
      
      # Extract the eigenvectors corresponding to the smallest `optimal_k` eigenvalues
      U <- eigen_decomp$vectors[, 1:optimal_k, drop = FALSE]
      
      # Normalize eigenvectors
      U <- sweep(U, 1, sqrt(rowSums(U^2)), '/')
      
      # Perform k-means clustering on the eigenvectors
      set.seed(123)
      phylo_clusters <- kmeans(U, centers = optimal_k, nstart = 25)$cluster
      
    } else {
      phylo_clusters <- rep(1, num_species)
    }
    
    # Compare clusters using ARI and NMI
    ari_values[i] <- compare(interaction_clusters, phylo_clusters, method = "adjusted.rand")
    nmi_values[i] <- compare(interaction_clusters, phylo_clusters, method = "nmi")
  }
  
  return(data.frame(
    timestep = 1:length(ari_values),
    ARI = ari_values,
    NMI = nmi_values
  ))
}

```



```{r}
library(igraph)

spectral_clustering <- function(graph, nb_cluster, normalized = TRUE) {#from J. Chiquet's git page https://jchiquet.github.io/MAP566/docs/mixture-models/map566-lecture-graph-clustering-part1.html
  
  ## Compute Laplcian matrix
  L <- laplacian_matrix(graph, normalized = normalized) 
  ## Generates indices of last (smallest) K vectors
  selected <- rev(1:ncol(L))[1:nb_cluster] 
  ## Extract an normalized eigen-vectors
  U <- eigen(L)$vectors[, selected, drop = FALSE]  # spectral decomposition
  U <- sweep(U, 1, sqrt(rowSums(U^2)), '/')    
  ## Perform k-means
  res <- kmeans(U, nb_cluster, nstart = 40)$cl
  
  res
}

compute_optimal_cluster_metrics_spectral <- function(results_simulation, Smax, nbasals) {
  
  presence_matrix <- results_simulation$presence_matrix
  
  # Number of timesteps
  n_steps <- length(results_simulation$network_list)
  
  # Identify valid timesteps
  non.valid_timesteps_phylo_distance <- which(rowSums(presence_matrix) < 3)
  final.discarded_timestep <- ifelse(length(non.valid_timesteps_phylo_distance) > 0, 
                                     max(non.valid_timesteps_phylo_distance) + 1, 1)
  
  list_anc_dist <- results_simulation$list_anc_dist[(final.discarded_timestep + 1):n_steps]
  network_list <- results_simulation$network_list[(final.discarded_timestep + 1):n_steps]
  
  # Convert species names to letters
  list_anc_dist_letters <- lapply(list_anc_dist, change_sppnames_letters_ancdist.table)
  list_networks_sppnames_numbers <- lapply(network_list, set_sppNames_numbers)
  list_networks_sppnames_letters <- lapply(list_networks_sppnames_numbers, convert_sppnames_toletters)
  
  colnames(presence_matrix) <- seq(1:Smax)
  colnames(presence_matrix) <- chartr("0123456789", "ABCDEFGHIJ", colnames(presence_matrix))
  
  presence_matrix <- presence_matrix[(final.discarded_timestep + 1):n_steps, ]
  
  # Store results
  ari_values <- numeric(length(list_networks_sppnames_letters))
  nmi_values <- numeric(length(list_networks_sppnames_letters))
  
  for (i in seq_along(list_anc_dist_letters)) {
    
    cat("Processing timestep:", i, "\n")
    
    # Process phylogenetic correlation matrix
    newick <- ToPhylo2(list_anc_dist_letters[[i]])
    newick_tail <- paste(newick, "root")
    tree <- read.tree(text = sub("A root",";", newick_tail))
    
    tree$edge.length <- sapply(tree$edge.length, function(x) ifelse(x == 0, 1e-5, x))
    phylo.vcv <- vcv(tree)
    phylo.corr <- cov2cor(phylo.vcv)
    
    alive_species <- names(which(presence_matrix[i, ] == 1))
    phylo_corr_cropped <- phylo.corr[alive_species, alive_species]
    
    # Clustering interaction matrix using SBM
    interaction_matrix <- list_networks_sppnames_letters[[i]][alive_species, alive_species]
    
    diag(interaction_matrix) <- 0  
    
    if (sum(interaction_matrix) == 0) {
      cat("Sparse or empty interaction matrix at timestep:", i, "- Assigning all species to one cluster.\n")
      interaction_clusters <- rep(1, nrow(interaction_matrix))
    } else {
      sbm_fit <- sbm::estimateSimpleSBM(interaction_matrix, model = "bernoulli")
      interaction_clusters <- sbm_fit$memberships
    }
    
    # **Spectral Clustering for Phylogeny**
    num_species <- nrow(phylo_corr_cropped)
    
    if (num_species > 2) {
      
      # Convert correlation matrix into an adjacency matrix (similarity graph)
      adjacency_matrix <- abs(phylo_corr_cropped) # Ensuring positive similarities
      diag(adjacency_matrix) <- 0  # Remove self-connections
      
      # Convert adjacency matrix into a graph
      phylo_graph <- graph_from_adjacency_matrix(adjacency_matrix, mode = "undirected", weighted = TRUE)
      
      # Select the number of clusters
      max_k <- min(4, num_species - 1)
      
      # Apply spectral clustering
      phylo_clusters <- spectral_clustering(phylo_graph, nb_cluster = max_k, normalized = TRUE)
      
    } else {
      phylo_clusters <- rep(1, num_species)
    }
    
    # Compare clusters using ARI and NMI
    ari_values[i] <- compare(interaction_clusters, phylo_clusters, method = "adjusted.rand")
    nmi_values[i] <- compare(interaction_clusters, phylo_clusters, method = "nmi")
  }
  
  return(data.frame(
    timestep = 1:length(ari_values),
    ARI = ari_values,
    NMI = nmi_values,
  ))
}

```

```{r}

compute_optimal_cluster_metrics_spectral <- function(results_simulation, Smax, nbasals) {
  
  presence_matrix <- results_simulation$presence_matrix
  
  # Number of timesteps
  n_steps <- length(results_simulation$network_list)
  
  # Identify valid timesteps
  non.valid_timesteps_phylo_distance <- which(rowSums(presence_matrix) < 3)
  final.discarded_timestep <- ifelse(length(non.valid_timesteps_phylo_distance) > 0, 
                                     max(non.valid_timesteps_phylo_distance) + 1, 1)
  
  list_anc_dist <- results_simulation$list_anc_dist[(final.discarded_timestep + 1):n_steps]
  network_list <- results_simulation$network_list[(final.discarded_timestep + 1):n_steps]
  
  # Convert species names to letters
  list_anc_dist_letters <- lapply(list_anc_dist, change_sppnames_letters_ancdist.table)
  list_networks_sppnames_numbers <- lapply(network_list, set_sppNames_numbers)
  list_networks_sppnames_letters <- lapply(list_networks_sppnames_numbers, convert_sppnames_toletters)
  
  colnames(presence_matrix) <- seq(1:Smax)
  colnames(presence_matrix) <- chartr("0123456789", "ABCDEFGHIJ", colnames(presence_matrix))
  
  presence_matrix <- presence_matrix[(final.discarded_timestep + 1):n_steps, ]
  
  # Store results
  ari_values <- numeric(length(list_networks_sppnames_letters))
  nmi_values <- numeric(length(list_networks_sppnames_letters))
  
  # Store trees and clusters
  original_trees <- list()
  pruned_trees <- list()
  phylo_clusters_list <- list()
  
  for (i in seq_along(list_anc_dist_letters)) {
    
    cat("Processing timestep:", i, "\n")
    
    # Process phylogenetic correlation matrix
    newick <- ToPhylo2(list_anc_dist_letters[[i]])
    newick_tail <- paste(newick, "root")
    tree <- read.tree(text = sub("A root",";", newick_tail))
    
    tree$edge.length <- sapply(tree$edge.length, function(x) ifelse(x == 0, 1e-5, x))
    phylo.vcv <- vcv(tree)
    phylo.corr <- cov2cor(phylo.vcv)
    
    # Save the full tree before pruning
    original_trees[[i]] <- tree
    
    # Get alive species
    alive_species <- names(which(presence_matrix[i, ] == 1))
    phylo_corr_cropped <- phylo.corr[alive_species, alive_species]
    
    # Prune the tree to only keep alive species
    pruned_tree <- keep.tip(tree, alive_species)
    pruned_trees[[i]] <- pruned_tree
    
    # Clustering interaction matrix using SBM
    interaction_matrix <- list_networks_sppnames_letters[[i]][alive_species, alive_species]
    
    diag(interaction_matrix) <- 0  
    
    if (sum(interaction_matrix) == 0) {
      cat("Sparse or empty interaction matrix at timestep:", i, "- Assigning all species to one cluster.\n")
      interaction_clusters <- rep(1, nrow(interaction_matrix))
    } else {
      sbm_fit <- sbm::estimateSimpleSBM(interaction_matrix, model = "bernoulli")
      interaction_clusters <- sbm_fit$memberships
    }
    
    # **Spectral Clustering for Phylogeny**
    num_species <- nrow(phylo_corr_cropped)
    
    if (num_species > 2) {
      
      # Convert correlation matrix into an adjacency matrix (similarity graph)
      adjacency_matrix <- abs(phylo_corr_cropped) # Ensuring positive similarities
      diag(adjacency_matrix) <- 0  # Remove self-connections
      
      # Convert adjacency matrix into a graph
      phylo_graph <- graph_from_adjacency_matrix(adjacency_matrix, mode = "undirected", weighted = TRUE)
      
      # Select the number of clusters
      max_k <- min(4, num_species - 1)
      
      # Apply spectral clustering
      phylo_clusters <- spectral_clustering(phylo_graph, nb_cluster = max_k, normalized = TRUE)
      
    } else {
      phylo_clusters <- rep(1, num_species)
    }
    
    phylo_clusters_list[[i]] <- setNames(phylo_clusters, alive_species)  # Save cluster assignments
    
    # Compare clusters using ARI and NMI
    ari_values[i] <- compare(interaction_clusters, phylo_clusters, method = "adjusted.rand")
    nmi_values[i] <- compare(interaction_clusters, phylo_clusters, method = "nmi")
  }
  
  return(list(
    results = data.frame(
      timestep = 1:length(ari_values),
      ARI = ari_values,
      NMI = nmi_values
    ),
    original_trees = original_trees,
    pruned_trees = pruned_trees,
    clusters = phylo_clusters_list
  ))
}



plot_phylo_clusters_at_timestep <- function(phylo_output, timestep) {
  
  # Extract pruned tree and clustering results
  tree <- phylo_output$pruned_trees[[timestep]]
  phylo_clusters <- phylo_output$clusters[[timestep]]
  
  # Ensure the tree contains only the clustered species
  if (length(tree$tip.label) != length(phylo_clusters)) {
    stop("Error: Clustering results do not match the number of species in the pruned tree.")
  }

  # Prepare data for plotting
  cluster_data <- data.frame(label = tree$tip.label, cluster = as.factor(phylo_clusters))
  
  # Plot the tree with colored clusters, explicitly passing data
  ggtree(tree) %<+% cluster_data +  # Attach cluster_data to tree
    geom_tippoint(aes(color = cluster), size = 3) +
    scale_color_manual(values = c("1" = "red", "2" = "blue", "3" = "green", "4" = "purple")) +
    theme_minimal() +
    labs(title = paste("Phylogenetic Clusters at Timestep", timestep),
         color = "Cluster")
}



plot_phylo_clusters_at_timestep <- function(phylo_output, timestep) {
  
  # Extract pruned tree and clustering results
  tree <- phylo_output$pruned_trees[[timestep]]
  phylo_clusters <- phylo_output$clusters[[timestep]]
  
  # Ensure species names are properly mapped
  species_names <- names(phylo_clusters)  # Extract species names from clusters
  tree_species <- tree$tip.label          # Extract species names from the pruned tree
  
  # Match clusters to tree species explicitly
  matched_clusters <- phylo_clusters[match(tree_species, species_names)]
  
  # Ensure there are no mismatches
  if (any(is.na(matched_clusters))) {
    stop("Error: Some species in the pruned tree do not have matching cluster assignments.")
  }
  
  # Prepare data for plotting
  cluster_data <- data.frame(label = tree_species, cluster = as.factor(matched_clusters))
  
  # Plot the tree with colored clusters
  ggtree(tree) %<+% cluster_data +  # Attach cluster data to tree
    geom_tippoint(aes(color = cluster), size = 3) +
    scale_color_manual(values = c("1" = "red", "2" = "blue", "3" = "green", "4" = "purple")) +
    theme_minimal() +
    labs(title = paste("Phylogenetic Clusters at Timestep", timestep),
         color = "Cluster")
}

# Run the function for a given timestep
plot_phylo_clusters_at_timestep(phylo_output, timestep = 50)


```

```{r}


phylo_output <- compute_optimal_cluster_metrics_spectral(results_simulation = res_sim, Smax = 1000, nbasals = 5)

library(ggtree)

plot_phylo_clusters_at_timestep(phylo_output, timestep = 50)

```



```{r}
library(ape)
library(cluster)
library(igraph)

plot_phylo_clusters_hclust_base <- function(results_simulation, timestep, Smax, nbasals, k_clusters = 4, use_eigenvector = FALSE) {
  
  presence_matrix <- results_simulation$presence_matrix
  
  # Extract pruned tree and clustering results
  list_anc_dist <- results_simulation$list_anc_dist[[timestep]]
  network_list <- results_simulation$network_list[[timestep]]
  
  # Convert species names to letters
  list_anc_dist_letters <- change_sppnames_letters_ancdist.table(list_anc_dist)
  network_letters <- convert_sppnames_toletters(set_sppNames_numbers(network_list))
  
  colnames(presence_matrix) <- seq(1:Smax)
  colnames(presence_matrix) <- chartr("0123456789", "ABCDEFGHIJ", colnames(presence_matrix))
  
  alive_species <- names(which(presence_matrix[timestep, ] == 1))
  
  # --------------------- Phylogenetic Tree Processing ------------------------
  
  newick <- ToPhylo2(list_anc_dist_letters)
  newick_tail <- paste(newick, "root")
  tree <- read.tree(text = sub("A root", ";", newick_tail))
  tree$edge.length <- sapply(tree$edge.length, function(x) ifelse(x == 0, 1e-5, x))
  
  phylo_vcv <- vcv(tree)
  phylo_corr <- cov2cor(phylo_vcv)
  phylo_corr_cropped <- phylo_corr[alive_species, alive_species]
  
  # Convert correlation matrix to distance matrix
  phylo_dist <- as.dist(1 - phylo_corr_cropped)
  
  # Hierarchical clustering on the phylogenetic correlation matrix
  hc_phylo <- hclust(phylo_dist, method = "ward.D2")
  phylo_clusters <- cutree(hc_phylo, k = k_clusters)
  
  # --------------------- Interaction-based Clustering ------------------------

  interaction_matrix <- network_letters[alive_species, alive_species]
  diag(interaction_matrix) <- 0  # Remove self-loops
  
  if (use_eigenvector) {
    # Eigenvector-based clustering (graph method)
    g <- graph.adjacency(interaction_matrix, mode = "undirected", diag = FALSE)
    clusters_eigen <- cluster_leading_eigen(g)
    interaction_clusters <- membership(clusters_eigen)
  } else {
    # K-means clustering
    set.seed(123)
    k_clusters_interaction <- kmeans(interaction_matrix, centers = k_clusters)
    interaction_clusters <- k_clusters_interaction$cluster
  }
  
  # --------------------- Compare Cluster Assignments ------------------------

  # Adjusted Rand Index (ARI)
  ari_value <- cluster.stats(d = phylo_dist, phylo_clusters, interaction_clusters)$corrected.rand
  
  # Normalized Mutual Information (NMI)
  nmi_value <- compare(as.integer(interaction_clusters), as.integer(phylo_clusters), method = "nmi")

  cat("Adjusted Rand Index (ARI):", ari_value, "\n")
  cat("Normalized Mutual Information (NMI):", nmi_value, "\n")
  
  # --------------------- Plot the Phylogenetic Tree ------------------------

  # Ensure the tree contains only the clustered species
  pruned_tree <- drop.tip(tree, setdiff(tree$tip.label, alive_species))
  
  # Ensure clustering results match pruned tree tips
  if (length(pruned_tree$tip.label) != length(phylo_clusters)) {
    stop("Error: Clustering results do not match the number of species in the pruned tree.")
  }
  
  cluster_colors <- rainbow(k_clusters)  # Generate distinct colors for clusters
  names(phylo_clusters) <- pruned_tree$tip.label  # Ensure correct tip labels
  
  # Open a plotting window
  par(mfrow = c(1, 2))  # Set 2-panel layout
  
  # 1. Plot the Phylogenetic Tree
  plot(pruned_tree, show.tip.label = TRUE, cex = 0.7, main = paste("Phylogenetic Clusters - Timestep", timestep))
  tiplabels(pch = 21, col = cluster_colors[phylo_clusters], bg = cluster_colors[phylo_clusters], cex = 1.2)
  
  # 2. Plot the Hierarchical Clustering Dendrogram
  plot(hc_phylo, labels = colnames(phylo_corr_cropped), main = "Phylogenetic Clustering Dendrogram", cex = 0.7, xlab = "")
  rect.hclust(hc_phylo, k = k_clusters, border = cluster_colors)
  
  par(mfrow = c(1, 1))  # Reset layout to single plot
  
}

# Run the function for a given timestep
plot_phylo_clusters_hclust_base(results_simulation = res_sim, timestep = 50, Smax = 1000, nbasals = 5, k_clusters = 4, use_eigenvector = FALSE)



```

